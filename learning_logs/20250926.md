# CORS Filter 추가하기
- CORS(Cross-Origin Resources Sharing): 클라이언트와 서버가 교차 출처 재요청을 허용할지 거부할지를 결정하는 특정 헤더를 가짐.
- CORS filter는 다른 출처에서 요청을 보내는 프론트엔드와의 통신에서 필요하다.
- 프론트엔드 상에서 특정 요청이 백엔드로 넘어가는 과정에서 CORS필터가 요청을 중간에 확인하여, 교차 출처로 식별되면 요청에 적절한 헤더를 추가하여 서로 통신을 주고받을 수 있도록 허용해준다.
- CorsConfigurationSource 인터페이스를 사용한다.
- 현재까지의 예제에서는 모든 출처의 HTTP 메서드와 헤더를 허용하는 상태이다.

1. SecurityConfig 클래스를 수정한다.

변경전
```java
package com.example.cardatabase;

import com.example.cardatabase.service.UserDetailsServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    private final AuthenticationFilter authenticationFilter;
    private final AuthEntryPoint exceptionHandler;

    public SecurityConfig(UserDetailsServiceImpl userDetailsService, AuthenticationFilter authenticationFilter, AuthEntryPoint exceptionHandler) {
        this.userDetailsService = userDetailsService;
        this.authenticationFilter = authenticationFilter;
        this.exceptionHandler = exceptionHandler;
    }

    public void configGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
    }

    //    이거는 암호화를 위한 과정
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .sessionManagement(sessionManagement ->
                        sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeHttpRequests ->
                        authorizeHttpRequests.requestMatchers(HttpMethod.POST, "/login").permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling ->
                        exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }
}

```

```java
package com.example.cardatabase;

import com.example.cardatabase.service.UserDetailsServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    private final AuthenticationFilter authenticationFilter;
    private final AuthEntryPoint exceptionHandler;

    public SecurityConfig(UserDetailsServiceImpl userDetailsService, AuthenticationFilter authenticationFilter, AuthEntryPoint exceptionHandler, CorsConfigurationSource corsConfigurationSource) {
        this.userDetailsService = userDetailsService;
        this.authenticationFilter = authenticationFilter;
        this.exceptionHandler = exceptionHandler;
    }

    public void configGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
    }

    //    이거는 암호화를 위한 과정
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .sessionManagement(sessionManagement ->
                        sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeHttpRequests ->
                        authorizeHttpRequests.requestMatchers(HttpMethod.POST, "/login").permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling ->
                        exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(Arrays.asList("*"));
        config.setAllowedMethods(Arrays.asList("*"));
        config.setAllowedHeaders(Arrays.asList("*"));

        config.setAllowCredentials(false);
        config.applyPermitDefaultValues();

        source.registerCorsConfiguration("/**", config); // /**는 모든 하위 폴더를 포함하는 개념
        return source;
    }
}

```
특정 Origin만을 명시적으로 정의하려면 
`config.setAllowOrigins(Arrays.asList("http://localhost:5173","http://localhost:3000"))`
과 같이 사용할 수 있다. 어차피 5173일테니 헷갈리면 ctrl + f로 5173 검색해두자.
2. SecurityConfig를 수정했으니 filterChain관련 method도 수정해야한다.

```java
import static org.springframework.security.config.Customizer.withDefaults;

@Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .cors(withDefaults()) // 여기 추가했다. 근데 static메서드 추가해야하는 import문도 추가됨 // 특정 포트만 연결해주는 부분
                .sessionManagement(sessionManagement ->
                        sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeHttpRequests ->
                        authorizeHttpRequests.requestMatchers(HttpMethod.POST, "/login").permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling ->
                        exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }
```

# Role-Based Protection
- Spring Security는 역할을 이용하여 세분화된 역할기반 보안을 정의할 수 있으며, 사용자는 하나 또는 여러 역할에 할당되어질 수 있다. 역할은 흔히 ADMIN / MANAGER / USER와 같은 계층구조를 가지는데 USER가 할 수 있는 모든 일은 MANAGER가 다 할 수 있으면서 MANAGER는 USER보다 더 많은 접근 권한을 가지고, ADMIN은 MANAGER가 할 수 있는걸 또다시 할 수 있으면서 자기만 할 수 있는 다른 접근 권한을 갖는 등으로 생각하면 된다.

SecurityConfig 클래스의 요청 수준에서 역할 기반 접근 제어를 정의할 수 있다. 이하의 예제코드는 접근을 위한 특정 역할이 필요한 엔드포인트를 정의할것이다. `/admin/**` 엔드포인트에 접근하려면 ADMIN 역할이 필요하고, `/user/**` 엔드포인트에 접근하려면 USER 역할이 필요한 등이 되겠다. 사용자가 지정된 역할을 가지고 있으면 true를 반환하는 Spring Security hasRole() 메서드를 이용한다.

Role-Based Protection 적용 filterChain 예시(예제 프로젝트에는 도입하지않았다.)
```java
 @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .cors(withDefaults())
                .sessionManagement(sessionManagement ->
                        sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeHttpRequests ->
                  authorizeHttpRequests.requestMatchers("/admin/**").hasRole("ADMIN").requestMatchers("/user/**").hasRole("USER").anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling ->
                        exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }
```

Spring Security는 Method 수준의 보안을 적용하는 데 이용되는 `@PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter, @Secured` 애너테이션들이 있다. 메서드 수준 보안은 default로 spring-boot-starter-security에서 이용하도록 설정되어있지 않다. 스프링 구성 클래스(최상위-우리 기준으로 CarDatabaseApplication)에서 `@EnableMethodSecurity` 애너테이션을 이용하여 활성화해야하는데 예시로 남겨두지는 않겠다.

# BackEnd Tests
