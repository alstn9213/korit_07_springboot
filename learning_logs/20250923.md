# SpringBoot Project 생성
https://start.spring.io
Gradle - Groovy
Java
3.5.6
Artifact com.example.cardatabase
Jar
17버전
그리고 Add Dependencies 클릭
Spring Web
springboot dev tools
Lombok
Spring Data JPA

Springboot의 간단 설명
Entity의 개념
JPA가 어떻게 Entity와 연결되었고, inmemory database인 h2와 어떻게 연결이 되었는지 여부도 수업
build.gradle / application.properties라고 하는 파일들에 명령어들을 작성했다.

Entity 클래스의 경우, DB에서의 table역할을 한다.
Entity 클래스의 field들은 column 역할을 함.
JPA와 연동되었기 때문에 필수적으로 기본 생성자를 요구한다.
id값을 AUTO로 잡았기때문에(즉, 생성될 때마다 db에서 고유 id값을 부여하기 때문에) @AllArgsConstructort를 적용하면 오류가 발생한다.


Lombok이 적용되지 않았을 때의 기본적인 Entity클래스 구조
```java

package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.NoArgsConstructor;

@Entity
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    private String firstName, lastName;
    //    Lombok 사용하지않고, 기본 생성자 및 ownerId를 제외한 requiredArgsConstructor 생성
//    Lombok 사용하지않고, 각 field에 대한 getter setter 생성할 것

    public Owner() {}

    public Owner(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public Long getOwnerId() {
        return ownerId;
    }

    public void setOwnerId(Long ownerId) {
        this.ownerId = ownerId;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }


}
```

Lombok이 적용된 Entity

```java

package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.*;

@Entity
@Getter
@Setter
@ToString
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    private final String firstName;
    private final String lastName;
}

```
`@NoArgsConstructor(force=true)` : final 필드가 있는 경우에도 해당 필드를 null로 초기화하는 생성자를 강제로 생성해주기 때문에 `final` 키워드가 붙은 경우에도 JPA에서 요구되는 기본 생성자를 만들 수 있고, 
`@RequiredArgsConstructor`와도 충돌하지않는다.

localhost:8080/h2-console 로 들어가서 좌측 확인하면 OWNER table이 생성된것을 확인가능

## 테이블 간의 관계 추가
car 테이블과 일대다(1:N)관계에 있는 owner라는 새 테이블을 만들 것이다. 일대다 관계는 소유자가 한명이 자동차 여러 대를 가질 수 있지만, 한 자동차의 소유자는 한명이라는 뜻이다.
domain 패키지에 Owner라는 엔티티 클래스와 OwnerRepository라는 repository 인터페이스를 만들어야한다. 그리고 OwnerRepository는 JpaRepository를 상속받아야한다.

이상의 일대다 관계를 추가하려면 `@ManyToOne`과 `@OneToMany` 애너테이션(jakarta.persistence)을 이용해야한다. 외래 키를 포함한 Car 엔티티 클래스에서는 `@ManyToOne`을 사용할 것이다. 그리고 외래키를 추가했기 때문에 field 구성이 달라져야한다. 그럼 DB적으로 봤을 때는 car table에다가 외래키인 ownerId를 추가하는 개념이라고 볼 수 있기 때문에 Car entity class에는 Owner관련 field를 추가해야한다. 그렇다면 새로 추가된 field에 대한 getter / setter 도 요구될 것 이다. 모든 JOIN관계에서는 FetchType.LAZY를 이용하는 것이 좋다. 대다(toMany) 관계의 경우에는 FetchType.Lazy가 기본값이므로 정의할 필요가 없지만 대일(toOne)관계의 경우 반드시 명시해줘야 한다.

FetchType: DB에서 데이터를 검색하는 전략을 정의. 속성값으로는
  EAGER : 즉시 검색
  LAZY : 지연 검색
예제에서는 지연 검색(LAZY)은 DB에서 소유자를 검색하면 필요할 때 해당 소유자와 연관된 모든 자동차를 검색한다는 의미이다. 반면 즉시 검색(EAGER)은 해당 소유자의 모든 자동차를 즉시 검색한다.

Car
```java
package com.example.cardatabase.domain;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;


@NoArgsConstructor
@Data
@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String brand, model, color, registrationNumber;
    private int modelYear, price;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "owner")
    private Owner owner;

    public Owner getOwner() {
        return owner;
    }

    public void setOwner(Owner owner) {
        this.owner = owner;
    }

    public Car(String brand, String model, String color, String registrationNumber, int modelYear, int price) {
        this.brand = brand;
        this.model = model;
        this.color = color;
        this.registrationNumber = registrationNumber;
        this.modelYear = modelYear;
        this.price = price;
    }

}


```
Owner
```java
package com.example.cardatabase.domain;

import jakarta.persistence.*;
import lombok.*;

import java.util.List;

@Entity
@Getter
@Setter
@ToString
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    @NonNull
    private final String firstName;
    @NonNull
    private final String lastName;


//    소유자는 다수의 차들을 가질 수 있기 때문에 Collections를 사용
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "owner")
    private List<Car> cars;

}

```

이상의 코드에서 `@Data`를 달아둔 경우에 일부러 겹치지만 Owner와 관련된 getter / setter 를 코드로 써두었다. 반면에 `@Getter, @Setter` 를 명시해둔 Owner 클래스에는 cars 관련 getter / setter 를 안썼다. 프로젝트할때는 setOwner() / getOwner()를 코드로 쓸 필요가 없다.

Owner class의 `@OneToMany` 애너테이션에는 특성이 있다.
1. cascade 속성은 삭제 / 업데이트 시 연속 효과가 적용되는 방법을 지정한다.
  - All로 설정하면 모든 작업이 연속적으로 적용된다.
  - 예를 들어 Owner를 삭제하면 그 소유자와 연결된 Car 객체들도 전부 다 삭제된다.
2. mappedBy="owner" 속성 설정 : Car클래스사이에 이 관계의 외래키인 owner 필드가 존재함을 명시함.

SQL을 배운 사람이 어색할 수 있는 것은 ownerId 필드 하나만 가지고 와서 연결짓는 게 아니라 Owner 클래스를 통째로 들고와서 Car의 field로 삼는다는 점이다.(무한 루프방지)

## H2 -> MariaDB로 이식
h2 버전을 push

git add .
git commit -m "feat: h2 인메모리 설정 관련 코드"
git push