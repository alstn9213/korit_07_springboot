# 계획
1. RESTful API 문서화 - 여긲가지 cardatabase # 1
2. 백엔드 보호 - cardatabase # 2 만들기
3. 백엔드 test case - cardatabase # 3 만들건데, 이때만 쓰고 # 2 기준으로 백엔드-프론트엔드 연결예정

# RESTful API 문서화
- RESTful API는 이를 이용하는 개발자가 그 기능과 작동을 이해할 수 있도록 적절하게 문서화 되어야한다.
- 명세서가 있으면 내가 개발한 메서드를 남이 사용할 수 있다.
- 이번에는 Open API 3를 이용하여 이용할 수 있는 엔드포인트 목록 / 허용되는 데이터 양식 / API와 상호작용하는 방법 등을 포함시킬 예정이다.

OpenAPI3를 이용한 자동 문서 생성방식(이전에는 Swagger 명세라고 했다)인데, 이는 RESTful API를 위한 API설명 명세서에 해당한다. RAML도 있긴한데 한국에서는 잘 안쓴다. 

OpenAPI도 라이브러리다. SpringDoc OpenAPI Starter WebMVC UI를 쓴다.
`	implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2'`



이제 알아야할 것은 '외부 라이브러리'를 사용한다면 Java 자체를 이용하는 것이 아니기 때문에 _의존성 추가_ 가 선행돼야한다는 것이다.
의존성 추가는 build.gradle -> denpencies 수정 -> 코끼리 클릭

2. com.example.cardatabase 패키지에 OpenAPIConfig 클래스를 생성.(config와 대응되는 한국어가 없다보니 앞으로는 구성이라하면 config라고 생각하자)

```java
package com.example.cardatabase;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {
    
    @Bean
    public OpenAPI carDatabaseOpenApi() {
        return new OpenAPI()
                .info(new Info()
                        .title("Car REST API")
                        .description("My car Stock")
                        .version("1.0")
                );
    }
}

```
이상의 코드에서 학습해야할 부분은 `@Bean`이라는 애너테이션이다.
그리고 return new OpenApi.info(...); 라는 지점에서 chaining method 개념을 도입했고, 거기 new Info() 내에서 객체생성을 빌더 패턴을 했다는 점에 주목하자. 그러면 `@Bean` 빼고는 전부 학습한 내용이다.

3. application.properties도 수정할 것이다.

```java
spring.application.name=cardatabase
spring.datasource.url=jdbc:mariadb://localhost:3310/cardb
spring.datasource.username=root
spring.datasource.password=1234
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=create-drop
spring.data.rest.basePath=/api
#spring.jpa.show-sql=true
springdoc.swagger-ui.enabled=true 추가
springdoc.swagger-ui.path=/swagger-ui.html 추가
springdoc.api-docs.path=/api-docs 추가

#spring.h2.console.enabled=true
#spring.h2.console.path=/h2-console

```

이후
localhost:8080/swagger-ui.html

# Bean / @Bean
- Spring에서 Bean은 스프링 IoC(Inversion of Control: 제어의 역전) 컨테이너가 관리하는 Java객체를 의미한다.

## Bean의 정의
Spring이 등장하기 전까지는 개발자가 직접 new 키워드를 통한 객체 생성을 하고, 객체간의 의존성을 관리했다.(우리가 Java시간에 해왔던 것) 프로젝트가 커질수록 코드가 복잡해지고 유지보수가 어려워지는 단점이 있다. 예를 들어 A클래스를 정의하고 B클래스에서 A클래스의 객체를 만들었을 떄 A클래스의 내부를 수정했더니 B에서 코드 오류가 나는 경우가 빈번했던 것이다.

Spring에서는 이상의 문제를 IoC개념을 통해서 해결했다. 개발자가 직접 특정 클래스에서 객체를 생성하는 것이 아니라 Spring IoC 컨테이너에게 객체 생성 자체를 위임한다. 스프링 컨테이너는 애플리케이션에서 필요한 객체를 미리 생성해두고(Bean), 필요할 때 특정 클래스에게 주입해준다. 이렇게 스프링 컨테이너에의해 관리되는 객체를 _빈_ 이라고 한다.

그리고 이 bean은 싱글톤 스코프로 관리된다. 그러면 전체를 통틀어서 하나의 객체만 생성되는 것을 담보하기 때문에 메모리 효율성을 높이고 일관된 상태를 유지할 수 있다.

## @Bean 애너테이션
`@Bean` 애너테이션은 메서드에 붙여서 사용하며, 이 메서드가 반환하는 객체를 스프링 컨테이너에 빈으로 등록하겠다는 의미이다.

### @Bean 애너테이션 사용방법
`@Bean`은 주로 `@Configuration`이 붙은 클래스 내부의 메서드에서 사용된다. `@Configuration`은 해당 클래스가 빈 설정 정보를 가지고 있음을 나타낸다.

- 우리가 Open API를 도입했을 때의 애너테이션을 확인하면 된다.
```java
package com.example.cardatabase;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI carDatabaseOpenApi() {
        return new OpenAPI()
                .info(new Info()
                        .title("Car REST API")
                        .description("My car Stock")
                        .version("1.0")
                );
    }
}
```

### @Bean의 사용여부에 따른 코드  라인의 차이
1. @Bean을 사용하지 않았을 때의 예시
  - @Bean을 사용하지 않으면 개발자가 직접 객체를 생성하고 관리한다.

```java
public class MyService {
  public void doSomething() {
    System.out.println("이 메서드가 일을 하고있습니다.");
  }
}

public class MyController{
  // 개발자가 직접 메서드를 호출하기 위해서 객체를 생성헀다.

  // 필드등록
  private MyService myService1 = new MyService();

  public MyService() {
    myService = new MyService();
  }

  public void handleRequest() {
    myService.doSomething(); // MyController 클래스에서 MyService 객체를 만든 다음에 메서드를 호출했다.
  }
}
```

지금까지는 이상한게 없다.

이상의 방식은 의존성 주입(Dependency Injection)을 활용하지않아, 객체간의 결합도가 높아지고 테스트 및 유지 보수가 어렵다는 단점이 있다. 즉, MyController 클래스만 테스트해보고 싶어도 내부에서 MyService 객체를 만들어버리니까 MyService 클래스까지 무조건 같이 테스트를 해야한다는 부분이 문제다. 만약에 특정 클래스에서 다른 클래스의 객체를 300개 만들면 301개의 클래스를 테스트해봐야한다.

2. @Bean을 사용했을 때의 예시
- @Bean을 사용하면 스프링 컨테이너가 MyService 클래스의 객체를 생성하고 관리한다. 그리고 `@Autowired`를 통해서 이 객체를 주입받아 사용한다.

```java
@Configuration
public class AppConfig{
  //  MyService 객체를 빈으로 등록하는 과정
  @Bean
  public MyService myService() {
    return new MyService();
  }
}

public class MyService {
  public void doSomething() {
    System.out.println("얘가 뭘 또 합니다");
  }
}

@Controller
public class MyController{
  private final MyService myService; // 아까 위와의 차이점은 우리가 이 클래스에서 객체를 생성하지않고서 field로 처리했다는 점이다.

  // 생성자 주입 
  public MyController(MyService MyService) {
    this.myService = myService
  }

  public void handleRequest() {
    myService.doSomething();
  }
}
```

이상의 예시에서 @Configuration이 붙어있는 AppConfig 클래스는 스프링 빈 구성 클래스로 동작한다. myService() 메서드에 @Bean 애너테이션을 붙여서, 결과값이 MyService의 객체가 되고, 이를 스프링 컨테이너에 등록한다. 이상의 작업이 선행되면 MyConTroller 클래스는 new 키워드 없이, 생성자를 통해 바로 스프링 컨테이너로 부터 MyService 객체를 전달받아서 사용할 수 있다. 그러면 객체가 통째로 하나만 있다는 것을 담보할 수 있기때문에 new를 쓸 때 처럼 객체 개수가 계속 늘어나지도 않고, 메모리 효율성과 일관성을 가질 수 있으면서도 MyController - MyService 클래스 같의 결합도도 낮추는 효과를 지닌다.

# 백엔드 보호로 넘어가기 전에 push한다.
git add . 
git commit -m "feat:RESTful API + Swagger"
git push

# 백엔드 보호

1. Spring Security
2. JWT를 이용한 백엔드 보호
3. Role-based 보호

## Spring Security
- 자체 기능
  1. 인메모리 사용자 하나를 포함하는 AuthenticationManger 빈. 사용자 이름은 user고 암호는 Console에 실행할 때마다 출력된다.
  2. `/css`, `/images` 같은 일반적인 정적 리소스 위치의 경로를 무시. 다른 모든 엔드 포인트에 대한 HTTP 기본 인증
  3. 스프링 ApplicationEventPublisher 인터페이스로 게시되는 보호이벤트
  4. HSTS, XSS, CSRF를 비롯한 일반적인 저수준 기능을 기본적으로 활성화
  5. 자동 생성되는 기본 로그인 페이지(한 번만 쓰고 안쓸거긴하다. - 지금 프론트가 없어서 임시적으로 쓰는 부분)

### Spring Security의 도입
1. build.gradle에 관련 의존성을 추가한다.
  - mvn에서 spring boot starter security 를 검색

depedencies에 추가
  ```java
  implementation 'org.springframework.boot:spring-boot-starter-security'
	testImplementation 'org.springframework.boot:spring-boot-starter-security'
  ```

  http://localhost:8080으로 접속하면 자기가 알아서 
  http://localhost:8080/login이라는 엔드포인트로 이동한다.
  username: user / password : 콘솔에 출력된 비밀번호를 붙여넣기하면
  http://localhost:8080/?continue 로 이동하는 것을 확인할 수 있는데 우리는 현재 
  http://localhost:8080에 입력한 것이 아무것도 없기때문에 whitelabel page가 나온다.
  http://localhost:8080/api/cars 이런거 들어가면 (API명세서에서 본 거 들어갔을때), 데이터가 이전과 같이 나온다면 정상처리된것이다.

  Spring Security의 작동 방식을 _구성_ 하려면 Config class를 추가해야한다. 특정 역할이나 사용자가 접근 가능한 URL 또는 URL 패턴을 정의할 수 있고, 인증 메커니즘, 로그인 프로세스, 세션 관리등을 정의하는 클래스에 해당한다.
  그래서 com.example.cardatabase 패키지에 SecurityConfig 클래스를 생성한다.

  ```java

package com.example.cardatabase;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public InMemoryUserDetailsManager userDetailsService() {
        UserDetails user = User.builder()
                .username("user")
                .password(passwordEncoder().encode("password"))
                .roles("USER")
                .build();
        return new InMemoryUserDetailsManager(user);
    }
    
//    이거는 암호화를 위한 과정
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

  ```
  이상의 SecurityConfig의 @Configuration, @EnableWebSecurity 애너테이션은 기본 웹 보호 구성을 해제하며, 이 클래스에서 자체 Config를 정의할 수 있도록 한다. 즉 애초에 Spring Securtiy에서 지원하는 보호 Config관련 설정들이 있는데 우리가 커스텀하겠다는 뜻이다. 인메모리 사용자를 추가했는데, 사실 이건 이번 테스트에만 쓸거기 때문에 큰 의미는 없고 오히려 @Bean을 통해 객체를 스프링 컨테이너에 등록헀고, 또한 PasswordEncoder 클래스의 객체를 생성하여 앞으로 암호 입력을 하더라도 DB에는 암호화가 이루어진 상태를 구현했다는 부분을 주목해야한다. 이상의 코드 구현에서는 결과적으로 username이 user / 비밀번호가 password(암호화 완료된) / 역할은 USER로 정의된 인메모리 사용자를 생성했다는 점이 된다.(builder pattern으로 만들었다는 것에도 주목해야한다.)

  인메모리 사용자를 만드는 것은 개발 단계에서는 괜찮지만 운영 환경에서는 사용자 정보를 DB에 저장한다. 그리고 유저 정보를 DB에 저장하려면 엔티티 클래스와 리포지토리 클래스가 있어야한다. 그리고 암호도 일반 텍스트 형식으로 DB에 저장되어서는 안될거고, 암호화 과정이 필요하다.

  com.example.cardatabase.domain 패키지에 AppUser 클래스를 만든다.

  ```java
package com.example.cardatabase.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.Setter;

@Entity
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
@Getter
@Setter
public class AppUser {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(nullable=false, updatable=false)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private final String username;
    
    @Column(nullable = false)
    private final String password;
    
    @Column(nullable = false)
    private final String role;
}

  ```
  이상의 코드에서 처음으로 @Column 사용을 통한 구체적인 컬럼 설정을 해봤다. name = 속성으로 컬럼명을 새로 커스텀하는 것부터 nullable로 null 허용 여부 / unique를 통해 다른 row들과의 차이를 식별할 것인지를 지정할 수 있다.
  username의 경우 일치하면 user들이 서로가 다른 사람인지 인지할 수 없으니 username은 unique 설정을, 비밀번호의 경우엔 애초에 인코딩되기도 하고 남이 알 일이 없으니 unique=false로 설정했다. 특정 컬럼이 어떤 속성을 지녀야하는지는 설계단계에서 고민해봐야한다.

2. AppUserRepository를 생성 -> 설정

이상의 코드에서 주목해야할 점은 여태까지 CarRepository에 추상메서드를 정의할 때는 결과값들이 기본적으로 복수로 나오기때문에 List 자료형을 썼지만 findByUsername()의 경우 username 필드가 unique=true이기 때문에 기본적으로 결과값이 하나이거나 아니면 0개가 나온다. 그래서 return type을 List로 설정하는 것은 적절하지 않은 선택지가 된다. 그렇다면 AppUser를 return하는 것이 적절하지만 예를 들어 옛날에는 
```java
public AppUser findByusername(String username) {
  if(username이 DB내에서 일치하는 username이 있다면 ){
    return 일치하는 객체 전체 리턴
  }
  return null;
}
```
와 같은 로직이 기본적으로 필요하다. 근데 여기는 interface이기 때문에 일반 메서드를 작성하지 못한다. 그 말은 결과적으로 AppUser를 return type으로 지정하면 AppUserRepository를 import해오는 곳마다 위의 로직을 계속  복사 붙여넣기해야한다는 뜻이다. 그래서 Optional이라고하는 클래스가 새로 나왔다. 얘는 null값으로 return 되더라도 일단 오류가 나지않는다.

3. domain과 같은 위치에 service 패키지를 생성
4. service 패키지 내에 UserDetailsServiceImpl이라는 클래스 생성
  - 이름이 길지만 Impl은 implement를 뜻한다.
  - implement의 의미는 특정 인터페이스의 추상 메서드들을 강제 구현하기 위한 명령어다.
  - 그래서 특정 클래스명이 Impl로 끝나게 되면 이는 어떠한 인터페이스를 구현한 클래스라고 해석하자.
  - 인터페이스명Impl.java의 형태로 작성된다.

```java
package com.example.cardatabase.service;

import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    private final AppUserRepository userRepository;
    
    public UserDetailsServiceImpl(AppUserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<AppUser> user = userRepository.findByUsername(username);
        User.UserBuilder builder = null;
        if(user.isPresent()) { // 이하의 실행문이 실행된다면 user에 AppUser 객체가 있다는 의미
            AppUser currentUser = user.get();
            builder = User.withUsername(username);
            builder.password(currentUser.getPassword());
            builder.roles(currentUser.getRole());
        } else {
            throw new UsernameNotFoundException("User not found");
        }
        return builder.build();
    }
}

```
이상의 코드에서 생기는 의문은 멀쩡하게 있는 AppUser 클래스의 객체인 user를 그대로 쓰는 것이 아니라 무슨 UserBuilder인가 하는 다른 클래스의 객체인 builder를 선언해놓고, 거기 내부에 AppUser의 field 값들을 하나씩 대입하는 로직이 있다는 것을 확인할 수 있다. 이는 인터페이스의 정의를 명확하게 알지 못하면 되게 효율적이지 못한 코드로 해석될 여지가 있다. 인터페이스 내에는 추상 메서드만 존재한다. 그리고 이를 구현하는 클래스는 인터페이스 내에 있는 추상 메서드들을 강제로 _구현(implement)_ 해야만 한다. 이미 우리가 AppUser라는 entity 클래스를 만들기 이전에 있는 인터페이스를 구현했으므로 당연히 거기에 있는 추상 메서드들의 return type은 AppUser가 아닐것이다. 또한 다른 개발자 들도 이 인터페이스를 구현할 테니까 특정 프로젝트에 맞는 entity 클래스라기 보다는 보편적인 형태의 return type을 요구하게 될 것이라고 생각할 수 있다. 그렇게 추상 메서드의 return type이 고정돼 있으므로 우리는 우리가 만든 entitiy class의 객체를 UserDetails클래스의 객체 형태로 대입해줄 필요가 있기 때문에 if문 내부의 실행문에서 해당 로직이 존재한다.

- 이상의 코드는 Spring Security 인증 처리시 DB에서 사용자를 가져오기 위해 UserServiceDetailsImpl 클래스에 AppRepository 클래스를 주입했다. 그리고 AppUserRepository에는 findByUsername() 메서드를 Optinal 결과값이 나오도록 작성해뒀다. 그래서 Optional에 딸린 메서드인 isPresent() 메서드를 통해 특정 usnername을 지닌 AppUser가 있는지 체크할 수 있게 된다. 그래서 user가 없다면 UsernameNotFoundException 예외를 발생시켜서 던진다.
- 그리고 강제 구현된 loadUserByUsername()메서드는 인증에 필요한 UserDetails 객체를 반환한다.(return type 확인할 것)

gitignore관련