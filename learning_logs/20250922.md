# 백엔드 환경 및 툴 설정
1. intellij installation 
2. gradle

## gradle의 이해
- 소프트웨어 개발 프로세스를 간소화 및 통합하는 빌드 자동화 툴이며, _프로젝트 의존성을 관리하고 빌드 프로세스를 처리_ 한다.
- Springboot와 함께 Maven(메이븐)이라는 다른 프로젝트 관리 도구를 쓸 수도 있지만 가시성이 좋은 gradle을 선택했다.
- gradle의 구성은 프로젝트의 build.gradle 파일에서 수행. 이 파일은 프로젝트의 특정 요구 사항에 맞게 사용자가 지정 가능하며, 소프트웨어 빌드, 테스트 및 배포와 같은 작업을 자동화 하는데 이용가능.
- 이상의 파일은 일반적으로 프로젝트 컴파일에 필요한 외부 라이브러리 및 프레임 워크 등 프로젝트의 의존성에 대한 정보를 포함(Java를 할때는 Lombok 설치가 이루어졌다.)
- build.gradle 파일을 작성할 때 Kotlin 또는 Groovy 프로그래밍 언어를 사용할 수 있는데, Groovy로 선택했었다.

### 일반적인 build.gradle 내부의 항목
1. 플러그인(plugins): 플러그인 블록은 프로젝트에서 쓰이는 gradle 플러그인을 정의하는 곳이며 우리는 이제 롬복뿐만 아니라 springboot 버전도 명시할 것이다.
2. 리포지토리(repository) : 의존성을 해결하는 데 쓰이는 의존성 리포지토리를 정의. 어기서는 gradle이 의존성을 가져오기위해 Maven Central 리포지토리를 사용할 예정.
3. 의존성(dependencies): 프로젝트에서 이용되는 _의존성_ 지정(의존성 수업 예정)
4. 태스크(tasks) : 테스트 등의 빌드 프로세스의 일부인 태스크를 정의

### 스프링 이니셜라이저 활용
http://start.spring.io

1. spring Web : Web 개발관련 설정을 default로 가지고있는 의존성.
2. Spring Boot Dev Tools : 자동 재시작 기능을 제공하는 의존성으로, 변경 내용을 저장할 때마다 애플리케이션이 자동 재시작되므로 덜 귀찮다.
```java
package com.example.cardatabase;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication {

    public static void main(String[] args) {
        SpringApplication.run(CardatabaseApplication.class, args);
    }

}
 
```
이상의 main에서 처음 보는 애너테이션인 `@SpringBootApplication` 이 있다.
여러 애너테이션의 조합으로 이루어진 것으로 필요한 부분들만 정리한다.

1. @EnableAutoConfiguration
    - 스프링부트의 자동 구성을 활성화. 프로젝트가 의존성에 따라 자동으로 구성되는데, 예를 들어 springboot-starter-web 의존성이 있는 경우 스프링부트는 사용자가 웹 애플리케이션을 개발중이라고 가정하고, 그에 따라 애플리케이션을 알아서 설정해준다.
2. @ComponentScan
    - 스프링부트 컴포넌트 검색으로 애플리케이션의 모든 컴포넌트를 찾을 수 있도록 함.
3. @Configuration
    - Bean 정의를 제공하는 소스로 쓸 수 있는 클래스를 지정.
### Spring Boot Dev Tools
- 이상의 의존성은 애플리케이션 개발 프로세스를 간략화해주는 의존성으로, 가장 중요한 것 중 하나는 클래스 경로의 파일이 수정될 때마다 스프링부트 애플리케이션을 자동으로 재시작해준다는 것이다.
### Logging / Problem-Solution
- 로깅은 애플리케이션의 흐름을 모니터링하는 데 이용할 수 있고, 프로그램 코드의 예기치않은 오류를 포착할 수 있는 좋은 방법이다. Spring Boot Starter 패키지에는 별도의 구성없이 로깅에 이용할 수 있는 LogBack이 있다.
- 로그백은 SLF4J(Simple Logging Facade For Java)를 기본 인터페이스로 사용한다. (facade: 정면)

```java
package com.example.cardatabase;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication {
	private static final Logger logger = LoggerFactory.getLogger(
			CardatabaseApplication.class
	);


	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
		logger.info("Application Started! / 애플리케이션이 실행되었습니다.");
	}

}

```
이상에서 주의할 점은 아까 본 것처럼 Logger 하나 import 하려고 할 때도 동일한 이름을 지닌 클래스 / 인터페이스가 많다는 점이다. 그래서 앞으로 수업할 때 웬만하면 import 경로도 같이 배울텐데, 나중에 오류가 날 경우 import 경로도 한번 확인해야한다.

logger.info() 메서드는 로그 메시지를 콘솔에 출력한다.

그리고 로깅 수준에는 TRACE / DEBUG / INFO / WARN / ERROR / FATAL / OFF 7가지로 나뉜다. 이를 application.properties 에서 설정할 수 있다. 이는 Java할 때는 한번도 본적없었던 resources 폴더 내에 있다.

`logging.level.root=DEBUG`로 작성한다면, 로그 수준이 DEBUG 및 그 이상(즉, DEBUG / INFO / WARN / ERROR)에 해당하는 로그 메시지를 볼 수 있다.

그리고 만약에 재시작한다면 TRACE 관련 메시지는 표시되지않는다. 별도로 지정하지 않은 default 로깅 수준은 INFO에 해당한다. 잘 쓰진 않음

그리고 스프링부트의 기본 port 번호는 8080에 해당한다.

실수를 많이 하는 부분은 코드를 수정했을 때 바로 실행버튼을 눌러서 port number가 겹쳐서 실행이 안되는 경우다. 수업 중에는 코드 수정 후에 종료를 누르는 것을 통제한다.

현재 port 구성은
Springboot: 8080
MariaDB : 3310

# 의존성 주입(Dependency Injection)
## 정의
- 다른 객체에 의존하는 객체를 만들 수 있는 소프트웨어 개발 기법
- 클래스 간의 상호작용을 도우면서 동시에 클래스를 독립적으로 유지
- 의존성 주입의 세 가지 클래스 유형
  1. 서비스(Service) : 클라이언트가 이용할 수 있는 클래스(의존성)
  2. 클라이언트(Client) : 의존성을 이용하는 클래스
  3. 주입기(Injector) : 의존성(서비스)을 의존 클래스(클라이언트)에 전달.
의존성 주입을 통해 클래스를 느슨하게 연결하는 것이 가능하다. 즉, 클라이언트 의존성의 생성이 클라이언트의 작동과 분리되어 단위 테스트가 더 쉬워진다.
예를 들어 일반적인 형태의 객체생성 과정을 보겠다.
```java
public class Car{
    // 필드정의
    private Owner owner;
    // 생성자
    public Car() {
        owner = new Owner();
    }
}
```

이상의 코드는 클라이언트 클래스인 Car가 서비스 클래스(Owner)의 객체를 생성하기 때문에 의존성 주입이 없다.
또 하나의 코드를 확인하자
```java
public class Car {
    private Owner owner;
    public Car(Owner owner) {
        this.owner = owner;
    }
}

public class CarMain{
    public static void main(String[] args){
        Car car1 = new Car(new Owner());
//        혹은
       Owner owner2 = new Owner();
       Car car2 = new Car(owner2);
    }
   
}
```
이상의 코드는 서비스 객체가 클라이언트 클래스에서 직접 생성되지 않는다. 대신 클래스 생성자에서 매개변수로 전달되는 예시이다.

여기서 client class가 Car고 의존성에 해당하는 것이 Owner라는 점에 유의해야한다.

또한 서비스 클래스는 추상 클래스일 수도 있다. 이 경우 클라이언트 클래스에서 해당 클래스의 어떤 구현이든 이용할 수 있고, 테스트 중에는 Mock을 이용할 수도 있다.
의존성 주입에도 마찬가지 유형이 있다.

## 의존성 주입 유형
1. 생성자(Constructor) 주입 : 의존성이 클라이언트 클래스 생성자에게 전달되는 방식. 생성자 주입의 예시는 앞의 Car 코드에서 확인 가능하다. 생성자 주입은 필수 의존성에 이용하는 것이 좋다. 모든 의존성은 클래스 생성자를 이용하여 제공되며 필수 의존성 없이는 객체를 생성할 수 없다.(즉 매개변수 생성자를 이용하라는 의미이다.)
2.  세터(Setter) 주입 : 의존성이 세터를 통해 제공되는 방식이다. 
```java
public class Car {
   private Owner owner;
   public void setOwner(Owner owner) {
      this.owner = owner;
   }
}
```
이상의 세터 주입은 아무런 의존성이 없더라도 객체를 생성할 수 있기 때문에 더 유연하다. 이 접근 방식은 선택적 의존성을 허용해준다.
의존성 주입은 코드의 의존성을 줄이고 코드를 _재사용하기 쉽게_ 만들어 준다.
이제 스프링 부트 상에서의 의존성 주입 부분을 학습한다.

## 스프링 부트에서의 의존성 주입 이용
스프링 프레임워크에서 의존성 주입은 스프링 ApplicationContext를 통해 이루어진다. 이는 객체(빈 bean)와 객체의 의존성을 생성하고 관리하는 역할.
스프링 부트 애플리케이션 클래스를 검색하여 특정 애너테이션(@Service / @Repository / @Controller 등)이 있는 클래스를 스프링 빈으로 등록한다. 의존성을 주입하면 이러한 빈을 주입할 수 있다.

아까 배운 생성자 주입 / 세터 주입 / 필드 주입 방식을 스프링부트 버전으로 풀어서 쓴다.

1. 생성자 주입
   - 생성자를 통해 의존성을 주입. 이 방법은 객체가 생성될 때 필요한 모든 의존성을 반드시 이용하게 되므로 가장 권장되는 방법이다. 가장 보편적인 상황은 특정 작업을 위해 DB에 대한 접근이 필요한 경우이다. 스프링 부트에서는 이를 위해 repository 클래스를 이용한다.
```java
public class Car {
   private final CarRepository carRepository;
   public Car(CarRepository carRepository) {
      this.carRepository = carRepository;
   }
//    DB상에서 CarRepository에 있는 모든 자동차 목록을 가져옴
   carRepository.findAll(); // SELECT * FROM car;
   carRepository.findOwners(); // SELECT owner FROM car;
}

```
여기서 중요한 것 중 하나는 .findAll();이라는 메서드가 메서드명이 고정되어있다는 점이다.
근데 클래스에 생성자가 여러 개 있는 경우 `@AutoWired` 애너테이션을 이용하여 의존성 주입에 이용되는 생성자를 정의해야한다.

```java
public class Car {
    private final CarRepository carRepository;
//     의존성 주입에 이용하는 생성자
   @AutoWired
    public Car(CarRepository carRepository) {
        this.carRepository = carRepository;
    }
}
```
2. 세터주입 : 의존성은 세터 메서드를 통해 주입된다. 세터 주입은 선택적 의존성이 있거나 런타임(프로그램 실행중)에 의존성을 수정하려는 경우에 유용하다.
```java
@Service
public class AppUserService {
//     필드정의
    private AppuserRepository userRepository;
    
    @AutoWired
    public void setAppUserRepository(AppUserRepository userRepository) {
        this.userRepository = userRepository;
    }
//     이상의 코드 그냥 일반적인 setter라고 볼 수 있다. call2() 유형
//      그러면 이제 userRepository를 이용한 다른 메서드들을 여기서 사용할 수 있다.
//      volumeUpButton을 이용했던 것 처럼
//      userRepository.findAll();로 전체 목록을 불러와서, 전체 user 숫자를 카운트한다든지 등.
}

```

3. 필드 주입 : 의존성을 필드에 직접 주입한다. 가장 단순하지만 의존성을 사용할 수 없는 경우에 런타임 에러가 발생할 수 있고, 테스트를 위해 모의 객체를 만드는 게 아니라 그때그때 새로운 객체가 만들어지기 때문에 테스트하기가 좀 어렵다.
```java
// 필드주입
@Service
public class CarDatabaseService implements CarService {
//    여기에 Car 데이터베이스 서비스가 있다고 가정한다.
}

public class CarController {
    @Autowired // 여기가 중요하다.
   private CarDatabaseService carDatabaseService;
}
```

# JPA를 이용한 데이터베이스 생성 및 접근
Springboot와 함께 JPA(Jakarta Persistence API / Java Persistence API)를 이용하는 방법 및 Entity 클래스로 데이터베이스를 정의하는 방법을 학습한다.(SQL로는 할 수 있었다.)
H2 인메모리 데이터베이스라는 개념을 학습할 것이다. 그리고 H2에서 MariaDB로 이동시킬 것이다. 동시에 CRUD Repository를 생성하고, 데이터베이스의 테이블과 엔티티 클래스의 관계에 대해 학습할 것이다.

## ORM / JPA / Hibernate 개념
ORM / JPA는 RDB를 처리하기 위해 소프트웨어 개발에서 널리 이용되는 기술로, 복잡한 SQL 쿼리를 작성할 필요없이 Java 개발자에게 친숙한 객체 형태로 DB를 조작할 수 있다. ORM / JPA는 SQL 코드 작성 및 디버깅에 소요되는 시간을 줄여준다.
대부분의 JPA 구현체들은 Java Entity 클래스를 바탕으로 DB의 스키마를 자동으로 생성할 수 있다.

1. ORM(Object Relation Mapping) : 객체 지향 프로그래밍 패러다임을 이용하여 DB를 가져오고 매핑할 수있는 기술. ORM은 데이터베이스 구조보다는 객체지향 개념을 바탕에 두고 있어서 Java개발자가 굳이 SQl까지 배울 필요성을 줄여준다는 점에서 장점이 있다. 그리고 장점은 ORM으로 개발하게 되면 DB와는 독립적으로 구동되기 때문에 개발자가 이용하는 DBMS가 무엇인지에 따라 달라지는 SQl 문에 대해 걱정할 필요가 없다. -> 즉, DB 이식이 쉽다.
2. JPA : Java 개발자를 위한 객체-관계형 매핑을 제공(ORM의 더 구체적인 버전이라고 생각하자). JPA 엔티티는 데이터베이스 테이블의 구조를 나타내는 Java 클래스에 해당한다. 엔티티 클래스의 필드는 데이터베이스 테이블의 Column을 나타낸다.
3. Hibernate : 최근에 가장 인기있는 JPA 구현체이고, 스프링 부트에서 기본 구현체로 이용된다. 대규모 애플리케이션에서 자주 쓰인다.
 
## 엔티티 클래스(Entity)
JPA에서 @Entity 애너테이션을 이용하는 Java 클래스로 표준 Java bean 명명 규칙도 따르고, 적절한 getter / setter 메서드도 가진다. 그리고 private로 설정한다.
애플리케이션이 초기화될 떄 _클래스 이름으로 테이터베이스의 테이블을 생성_ 한다. 만약 다른 이름으로 지정하고 싶으면 엔티티 클래스에 @Table 애너테이션을 별개로 달 수 있는데, 이는 추후 수업예정.

그럼 알 수 있는 것 ->
1. field 명이 column명이 된다.
2. class 명이 table명이 된다.

H2 데이터베이스 / JPA 이용을 위해 build.gradle을 수정한다.

수정 전
```java
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```
수정 후
```java
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa' 추가
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	runtimeOnly 'com.h2database:h2' 추가
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

```

Car Entity class
```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    
    private String brand, model, color, registrationNumber;
    
    private int modelYear, price;
}


```
1. @Id: DB에서의 테이블의 Primary Key에 해당하는 field에 달아주는 애너테이션(그럼 DB에서의 기본 키 개념을 명확히 알아야한다.)
2. @GeneratedValue : 데이터베이스가 자동으로 ID를 생성하도록 지정(ID값을 우리가 객체 생성할 때 일일이 넣지 않는다는 것을 의미한다. 다른 키 생성 전략을 사용할 수도 있다.) AUTO는 JPA 공급자가 특정 데이터베이스에 가장 적합한 전략을 선택한다는 의미로, default 값이다.

- DB에서 column명은 기본적으로 클래스 필드 명명 규칙에 따라 지정된다. 그래서 다른 컬러명으로 지정하고 싶다면 @Column 애너테이션을 활용하여 커스텀할 수도 있다. 또한
3. @Column : 컬럼명을 사용자화 / 컬럼의 길이 / 컬럼의 nullable 여부를 지정하는 것도 가능하다. 예시는 이하와 같다.

```java
import javax.annotation.processing.Generated;

@Entity
public class Car {
   @Id
   @GeneratedValue(strategy = GenerationType.AUTO)
   private Long id;
   
   @Column(name="explanation", nullable=false, length=512)
   private String description;
}
```
즉, Car 클래스의 description 필드는 car 테이블에서는 explanation 이라는 컬럼명을 갖게되고, VARCHAR(512)로 데이터 길이가 지정되었으며, null 불가라는 의미를 지닌다.

application.properties에 이제 h2 인메모리 DB를 사용할 거라는 것을 적어준다.

```properties
spring.application.name=cardatabase
spring.datasource.url=jdbc:h2:mem:testdb
spring.jpa.show-sql=true
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

```
chrome에서 
localhost:8080/h2-console 접속

수강생들의 오류 모음
1. domain 패키지가 test내에 있었던 경우 실행은 됐으나 sql문이 실행안됨.
2. application.properties에서 오타
   - 이상의 경우 생기는 문제점은 실행은 된다는 점이다. 예상했던 결과값이 콘솔에 안찍힌다.

## CRUD repository 생성
Spring Data JPA에는 CRUP 작업을 위한 CrudRepository라는 인터페이스가 있다. 해당 인터페이스는 엔티티 클래스에 CRUD 기능을 제공한다.

1. domain 패키지에 interface인 CarRepository 생성.
```java0
package com.example.cardatabase.domain;

import org.springframework.data.repository.CrudRepository;

public interface CarRepository extends CrudRepository<Car, Long> {
    
}

```
CarRepository는 스프링부트 JPA의 CrudRepository 인터페이스를 바탕으로 확장된 클래스이다.(상속 받았으니까 부모 클래스의 필드/메서드를 사용할 수 있다. 근데 둘 다 인터페이스니까 추상 메서드를 상속받았다고 볼 수 있다.). 그리고 `<Car, Long>` 타입의 argument는 Car 엔티티 클래스의 리포지토리이고, id 필드의 타입이 Long임을 명시했다. 이상의 제네릭으로 인해 Car - CarRepository 관계가 Entity - Repository 관계로 성립된다.

CrudRepository 인터페이스에는 당연히 추상 메서드들이 있을 것이다. 일반적으로 사용되는 메서드 목록을 명시하겠다.
### CrudRepository의 추상메서드 소개
1. long count() - 엔티티의 수를 반환
2. Iterable<T> findAll() - 지정한 타입의 모든 항목을 반환 - Read
3. Optional<T> findById(ID id) - 지정한 ID의 한 항목을 반환(JS에서 getElementById()와 유사) - Read
4. void delete(T entity) - 엔티티 삭제 - Delete
5. void deleteAll() - 리포지토리 내의 모든 엔티티삭제 - Delete
6. `<S extends T>` save(S entity) - 엔티티를 저장 - Create
7. `List<S>` saveAll(`Iterable<S>` entities) - 여러 엔티티를 저장 - Create

method가 한 항목만 반환할 때는 T대신에 `Optional<T>`를 반환한다. Optional 클래스는 Java 8 SE에서 처음 도입된 타입으로, 값을 포함하거나 포함하지 않는 단일 값 컨테이너이다.(특정 id값이 없는 경우에 보통 메서드 결과값이 오류로 발생하기 때문에 이를 막는 용도로 Oprional을 사용한다.) 값이 있으면 isPresnet() 메서드가 true를 반환하고 없으면 false를 반환한다. 그리고 값이 있을 때만 get()메서드를 통해 값을 얻는다.
해당 Optional을 사용하면 NullPointerException을 방지할 수 있다.

2. 이제 H2 인메모리에 예제 데이터들을 넣는다. 인메모리 DB는 실행될 때마다 DB를 새로 만들고, 종료될때 삭제하기 때문에 현재 h2-console에서 값을 입력해도 껐다 키면 없어진다. 이를 방지하기 위해 Springboot 프로젝트 내에 예제 데이터를 넣는다.

CommandLineRunner 인터페이스를 사용 -> 애플리케이션이 완전히 시작되기 전에 특정 코드를 실행할 수 있다.
CarDatabaseApplication에 CommandLineRunner를 구현한다.

```java
package com.example.cardatabase;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication implements CommandLineRunner {

	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
	
	}

	@Override
	public void run(String... args) throws Exception {
		
	}
}

```

다음, 새로운 Car 객체를 데이터베이스에 저장할 수 있도록 CarRepository를 main 클래스에 주입한다. 생성자 주입 개념을 통해 CarRepository를

```java
package com.example.cardatabase;

import com.example.cardatabase.domain.Car;
import com.example.cardatabase.domain.CarRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication implements CommandLineRunner {
	private static final Logger logger = LoggerFactory.getLogger(
			CardatabaseApplication.class
	);
//	여기에 생성자 주입 부분을 적는다.
	private final CarRepository repository;

    public CardatabaseApplication(CarRepository repository) {
        this.repository = repository;
    }

    public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
		logger.info("Application Started! / 애플리케이션이 실행되었습니다.");
	}

//	CommandLineRunner 인터페이스의 추상메서드인 run()을 여기서 구현한다.
	@Override
	public void run(String... args) throws Exception {
//			내부에서 CarRepository의 객체인 repository의 메서드를 호출한다.
		repository.save(new Car("Kia", "Seltos", "Chacol", "370SU5690", 2020, 30000000));
		repository.save(new Car("Hyundai", "Sonata", "White", "123456", 2025, 25000000));
		repository.save(new Car("Honda", "Treno", "Black-White", "987654", 2024, 80000000));
//		-> 이상의 코드는 testdb 내의 CAR 테이블 내에 3개의 row를 추가하여 저장한다는 의미이다.
//		java 기준으로는 객체 세 개를 만들어서 저장했다고도 볼 수 있다.

//		모든 자동차를 가져와서 Console에 로깅해보겠다.
		for(Car car : repository.findAll()) {
			logger.info("brand : {} , model : {}", car.getBrand(), car.getModel());
		}
	}
}


```

Car entity 클래스에서 기본 생성자 삭제헀고, getter / setter도 삭제했다.
해당 부분을 Lombok 라이브러리의 도입을 통해 오류해결

1. intellij 상에 plugin에 롬복이 깔려있는지 체크
   - ctrl + alt + s 눌러서 설정으로 들어가서 플러그인을 클릭
2. chrome에서 mvn 검색 -> lombok 검색 -> version 최신버전을 받는다.
   - groovy short 인지 확인
3. build.gradle 가서 dependencies에 implementation 'org.projectlombok:lombok:1.18.42' 이거 붙여넣는다.
4. annotationProcessor 'org.projectlombok:lombok:1.18.42' 도 붙여넣는다. 
그 결과는
```java
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	runtimeOnly 'com.h2database:h2'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
    // 롬복 관련 의존성
	implementation 'org.projectlombok:lombok:1.18.42'
	annotationProcessor 'org.projectlombok:lombok:1.18.42'
}
```
그러고 파란색 코끼리 누르기

Spring Data Repository에 쿼리를 정의하는 것도 가능하다.(SQL을 의미하는 것이 아니다. SQL로도 쓸 수 있다.) 쿼리는 접두사(prefix: findbt 등)로 시작해야하고, 그 다음에는 쿼리에 이용할 엔티티 클래스 필드를 정의해야한다.

그러면 main에
```java
System.out.println(repository.findByBrand("kia"));
```
라고 작성했을 시 콘솔 창에
`[Car(id=1, ...,)]` 과 같은 형태로 나온다.
안나온다면 아마 Car 엔티티 클래스에 `@Data`가 아니라 `@Getter`, `@Setter` 를 애너테이션 달아놨기 때문에 `@ToEntity` 애너테이션 효과가 없어서 객체의 주소값만 나왔을 수도 있다.

CarRepository에 색상으로 자동차들을 검색할 수 있도록 메서드를 정의하고 main에 White 색을 호출하여 콘솔창에 표시
CarRepository에 연도로 자동차들을 검색할 수 있도록 메서드를 저으이하고 main에 2024로 호출하여 콘솔창에 표시.

```java
package com.example.cardatabase.domain;

import org.springframework.data.repository.CrudRepository;

import java.util.List;

public interface CarRepository extends CrudRepository<Car, Long> {
//    브랜드로 자동차를 검색
    List<Car> findByBrand(String brand);

//    색상으로 자동차를 검색
    List<Car> findByColor(String color);

//    연식으로 자동차를 검색
    List<Car> findByModelYear(int modelYear);

//    브랜드와 모델을 합쳐서 자동차를 검색
    List<Car> findByBrandAndModel(String brand, String model);

//    브랜드 또는 색상별로 자동차를 가져오기
    List<Car> findByBrandOrColor(String brand, String color);

//    브랜드로 자동차를 검색하고 연도로 정렬
    List<Car> findByBrandOrderByModelYearAsc(String brand);
}

```
`@Query` 애너테이션을 사용하면 직접 SQL문을 작성함으로써 쿼리 메서드를 만드는 것도 가능하다. 근데 이름은 어차피 고정되어있다.

```java
  @Query("select c from Car where c.brand = ?1")
    List<Car> findByBrand(String brand);

```
근데 지금 보면 어차피 @Query가 있으나 없으나 List부분은 똑같이 작성되는 것을 알 수 있다. 그런데 어떨 때 쓰냐면 엄청 복잡한 쿼리를 작성해야할 때이거나, 아니면 Like와 같은 고급 표현식을 사용할 때 적용할 수 있다.
우리가 처음 작성한 방식대로라면
```java
System.out.println(repository.findByBrand("Kia"));
```
로 완벽하게 작성해야만 튀어나온다.
```java
System.out.println(repository.findByBrand("Ki"));

```
이렇게 쓰면 Ki라는 brand가 존재하지 않는다면 아예 결과값이 나오지않는다. 하지만 @Query를 사용하게 될 경우 LIKE를 적용할 수 있기때문에 

```java
// SQL문을 활용한 브랜드로 자동차 검색
    @Query("select c from Car c where c.brand = ?1")
    List<Car> findByBrand(String brand);
//SQL을 활용한 브랜드로 자동차를 검색하는데 부분 검색을 적용
    @Query("select c from Car c where c.brand like %?1")
    List<Car> findByBrandEndsWith(String brand);

    @Query("select c from Car c where c.brand like ?1%")
    List<Car> findBtBrandStartsWith(String brand);
```

Spring Data JPA에서는 CrudRepository로부터 확장된 PagingAndSortingRepository도 있다. 이 인터페이스는 페이징 및 정렬을 통해 엔티티를 검색하는 메서드를 제공한다. 이 경우 대규모 결과 집합에서 모든 데이터를 반환할 필요가 없기때문에 대규모 데이터를 처리하기에 적합하다.
```java
import org.springframework.data.repository.PagingAndSortingRepository;

public interface CarRepository extends PagingAndSortingRepository<Car, Long> {

}

```
제공하는 메서드
1. Iterable<T> findAll(Sort sort) - 지정된 옵션으로 정렬된 모든 엔티티를 반환
2. Page<T> findAll(Pagable pagable) - 지정한 페이징 옵션으로 모든 엔티티를 반환

결과적으로 JpaRepository를 쓴다.

## 테이블 간의 관계 추가
car 테이블과 일대다(1:N)관계에 있는 owner라는 새 테이블을 만들 것이다. 일대다 관계는 소유자가 한명이 자동차 여러 대를 가질 수 있지만, 한 자동차의 소유자는 한명이라는 뜻이다.
domain 패키지에 Owner라는 엔티티 클래스와 OwnerRepository라는 repository 인터페이스를 만들어야한다. 그리고 OwnerRepository는 JpaRepository를 상속받아야한다.

### JWT 생성 및 해석과 응용과정
1. Java / Android 용 JWT 라이브러리인 jjwt 라이브러리 의존성을 추가해야한다.
    - jwt -> JSON web Token -> JavaScript Object Notation Web Token
    - jjwt -> Java JavaScript Object Notation Web Token
    

2. 로그인 보호
    1. JWT를 생성하고 검증하는 클래스를 만들것이다. service 패키지에서 JwtService 클래스를 만들것이다.

```java
package com.example.cardatabase.service;

import org.springframework.stereotype.Component;

@Component
public class JwtService {
//    1일(밀리초). 실제 운영시에는 더 짧은게 더 낫다.
    static final long EXPIRATIONTIME = 86400000;
    static final String PREFIX = "Bearer";
    
}

```
만료시간 필드의 경우에는 그냥 1일을 밀리초 단위로 곱한 개념이다.
PREFIX는 토큰의 접두사를 의미하는데, 일반적으로 "Bearer" 스키마가 이용되는 편이다.
JWT는 Authorization 헤더로 전송되면서 Bearer 스키마를 이용하는 경우의 예시는 이하와 같다.
`Authorization: Bearer <token>` Bearer 뒤에는 반드시 공백이 있어야한다. 나중에 접두사를 제거하고 token의 값만 가지고 유효성을 검증해야하기 때문에 Bearer 접두사를 제거하는 과정에서 공백을 제거하지않는 바람에 결과값이 `<token>`이 아니라 ` <token>`이 되어서 유효성 검증에 통과하지못하는 경우가 많다.

    2. jjwt 라이브러리의 secretKeyFor() 메서드를 이용하여 비밀키를 생성할 것이다. 시연용으로만 사용될 거고 실제 DB에는 잘 모르겠다. 운영 환경 상에서는 애플리케이션 구성에서 비밀 키를 읽어와야하는 등 약간 차이가 생긴다.
        - 이후 getToken() 메서드를 활용하여 토큰을 생성하고 return
        - getAuthUser() 메서드를 통해 Authorization 헤더에서 토큰을 가져온다.
        - jjwt 라이브러리에서 제공하는 parseBuilder() 메서드를 활용, jwtParseBuilder 인스턴스를 생성할 것이다.
        - setSigningKey() 메서드로 토큰 확인을 위한 비밀 키 지정을 한다.(setter이다)
        - parseClaimsJws() 메서드로 Authorization 헤더에서 Bearer 접두사를 제거한다.
        - getSubject() 메서드로 username을 가져올 것이다. 아래에는 이상의 과정을 코드로 작성한 예다.


```java
package com.example.cardatabase.service;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;

@Component
public class JwtService {
//    1일(밀리초). 실제 운영시에는 더 짧은게 더 낫다.
    static final long EXPIRATIONTIME = 86400000;
    static final String PREFIX = "Bearer";

//    비밀키 생성.
    static final Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);

//    서명이 이루어진 JWT 토큰을 생성
    public String getToken(String username) {
        String token = Jwts.builder()
                .setSubject(username)
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATIONTIME))
                .signWith(key) // 위에 만들어둔 비밀키로 서명
                .compact();

        return token;
    }
// 요청 (Request)의 Authorization 헤더에서 토큰을 가져온 뒤에 그 토큰 내부를 확인하고,
//    username을 가지고 오는 부분이다.
    public String getAuthUser(HttpServletRequest request) {
        String token = request.getHeader( // 이 클래스의 객체가 정확히 뭔지는 모르겠지만 method 명을 봤을 때 Header를 가지고 온다는 것은 알 수 있다.
//          여기 Header는 postman에서 볼 수 있는 headers에 해당한다.
                HttpHeaders.AUTHORIZATION
        );
        if(token != null) {
            String user = Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token.replace(PREFIX, ""))
                    .getBody()
                    .getSubject();
            
            if(user != null) return user;
        }
        return null;
        
    }
    
}

```
이상의 코드쓰는 것에서 생겨난 문제점 미리 적어 놓는다. build.gradle에서의 jjwt 관련 version 불일치로 인해서 parserBuilder() 메서드가 더이상 지원되지 않는다는 문제점이 발견됐다. 그래서 0.11.5 로 수정했다.

```java
plugins {
	id 'java'
	id 'org.springframework.boot' version '3.5.6'
	id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'
description = 'Demo project for Spring Boot'

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(17)
	}
}

repositories {
	mavenCentral()
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
//	Spring Data REST 의존성 추가 영역
	implementation 'org.springframework.boot:spring-boot-starter-data-rest'

	developmentOnly 'org.springframework.boot:spring-boot-devtools'
//	runtimeOnly 'com.h2database:h2'
	runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'

	implementation 'org.projectlombok:lombok:1.18.42'
	annotationProcessor 'org.projectlombok:lombok:1.18.42'

//	OpenAPI 명세서 관련 의존성
	implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2'
	implementation 'org.springframework.boot:spring-boot-starter-security'
	testImplementation 'org.springframework.boot:spring-boot-starter-security'

//	jjwt 관련설정
	implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
	runtimeOnly 'io.jsonwebtoken:jjwt-api:0.11.5'
	runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
}

tasks.named('test') {
	useJUnitPlatform()
}

```
버전 불일치로 인한 코드 작성 방식의 변경은 빈번하게 일어나는 편이다. 근데 최신버전이 LTS로 넘어가기 전까지는 사용하지 않는 편이 좋다. 이상의 코드에서 일단은 getToken()을 통해 토큰을 생성하는 메서드와 getAuthUser() 메서드를 통해 토큰을 확인하여 서명된 user를 return하도록 정의했다.

    3. Authentication을 위한 자격 증명 자체를 저장하는 클래스를 추가할 예정이다. 여기서 Record라는 자료형을 사용할텐데 내일한다.