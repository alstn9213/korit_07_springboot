# ORM
- 자바의 객체와 데이터베이스를 연결하는 프로그래밍 기법. ORM이 있으면 데이터베이스의 값을 객체처럼 사용할 수 있다.

## JPA
- DBMS에 여러 종류가 있는 것처럼 ORM에도 여러 종류가 있다. 자바에서는 JPA를 표준으로 사용한다.
- JPA는 자바에서 관계형 데이터베이스를 사용하는 방식을 정의한 `인터페이스` 이다.
- JPA는 인터페이스이므로 이를 구현할 구현체가 필요한데 대표적으로 하이버네이트가 있다.
- 그렇다면 하이버네이트가 클래스이고 하이버네이트를 객체로 만들면 데이터베이스와 상호작용할 수 있는가? 아니다. 데이터베이스의 정보를 담는 객체는 엔티티라고 하는데, 엔티티는 엔티티 클래스를 가질 뿐 하이버네이트 타입을 가지지 않는다.

```java
@Entity // 엔티티 클래스
public class Owner { // Owner 클래스의 객체를 생성하면 엔티티가 된다.
    @Id @GeneratedValue
    private Long id;
    private String name;
}
```
- 다만, 엔티티를 JPA를 통해 조회할 때 하이버네이트가 개입한다. 단순히 new Owner()로 만드는 게 아니라, 필요하면 프록시 객체(Hibernate가 만든 Owner의 서브클래스)를 반환한다. 이 프록시 객체는 Owner 타입이지만, 내부적으로는 하이버네이트의 Lazy Loading 같은 기능을 수행할 수 있다.

# 엔티티

- 사용자가 데이터베이스에 정보를 요청하면 엔티티 매니저가 데이터베이스의 정보들을 뽑아 엔티티에 담아서 사용자에게 돌려준다. 사용자는 자바에서 엔티티를 객체처럼 사용할 수 있다. 엔티티 팩토리는 무겁고 비싼 객체라서 애플리케이션 시작 시 딱 한 번 생성해두고 공유한다.
- 스프링 부트 환경에서는 @PersistenceContext 같은 걸 통해 알아서 주입받는다.

## 엔티티 팩토리의 생성 비용이 많이 든다는 것의 의미.

엔티티 팩토리가 생성될 시

1. 메타데이터 분석
- @Entity 붙은 클래스들을 전부 스캔해서, “어떤 클래스가 어떤 테이블과 매핑되는지”, “어떤 필드가 컬럼인지, 어떤 게 연관관계인지” 등을 전부 파싱해서 **매핑 정보(메타데이터)**를 만든다.
- 엔티티 수가 많을수록 초기 작업량이 많아진다.

2. 데이터베이스 연결 준비
- DB 드라이버 로딩, 커넥션 풀(Connection Pool) 설정, Dialect(데이터베이스 방언) 확인 같은 작업을 한다. 즉, “DB랑 대화하기 위한 환경”을 전부 준비한다.

3. 캐시, 쿼리 플랜 등 초기화
- JPA가 내부적으로 사용할 1차/2차 캐시, JPQL 파서, SQL 생성기, 쿼리 플랜 등을 초기화한다. Hibernate 같은 구현체는 이 과정에서 꽤 많은 객체를 만든다.